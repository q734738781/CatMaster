"""
Prepare MPRelax-style VASP input sets via StructWriter.
"""

from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, List, Optional
from ase.io import read as ase_read
from pydantic import BaseModel, Field
from pymatgen.core import Structure
from pymatgen.io.ase import AseAtomsAdaptor

from .vasp_inputs import StructWriter
from catmaster.tools.base import create_tool_output, resolve_workspace_path, workspace_relpath


SUPPORTED_EXTS = {".vasp", ".cif"}


class RelaxPrepareInput(BaseModel):
    """
    Prepare MPRelaxSet-based VASP relax inputs with calc_type presets and k_product k-mesh. 
    Also can be modified for other calculation types by overriding the user_incar_settings.
    Support exts: .vasp, .cif

    Baseline DFT settings follow Materials Project MPRelaxSet (key defaults):
    - PBE54 POTCARS, ENCUT=520 eV, PREC=Accurate, ISPIN=2, IBRION=2, LREAL=AUTO, LASPH=True, LORBIT=11, LWAVE=False, LCHARG=False).
    - Additional overrides applied based on calc_type: ISMEAR=0, SIGMA=0.1 for bulk/slab/lattice; ISMEAR=0, SIGMA=0.01 for gas;
    - Additionally, 'lattice' will apply ISIF=3; 'bulk' will apply ISIF=2; 'slab' will apply ISIF=2 and force KPOINTS in z direction to 1; gas will apply ISIF=2, ISYM=0, LREAL=False, and force KPOINTS to 1x1x1
    - Improved convergence settings: EDIFF=1e-6; NSW=500; EDIFFG=-0.02;
    - KPOINTS is generated by k*a=k_product, where a is the lattice constant in Angstrom. Set to 30 by default and sufficient for most systems.
    - DFT-D3 and DFT+U are disabled by default. Enable them if the system is adsorption system(DFT-D3) or transition metal oxide system(DFT+U).
    """

    input_path: str = Field(
        ...,
        description="Path to a structure file with lattice information (POSCAR/CIF) or a directory containing multiple structures. Support exts: .vasp, .cif",
    )
    output_root: str = Field(
        ...,
        description=(
            "Root directory for generated VASP inputs (one subfolder per input structure). "
            "If input_path is a file: output_root/<stem>/...; if input_path is a directory, "
            "preserve relative subfolders: output_root/<relpath>/<stem>/..."
        ),
    )
    calc_type: str = Field(
        "bulk",
        description=(
            "Calculation type: 'gas'|'bulk'|'slab'|'lattice'. "
            "This provides preset INCAR overrides for different calculation types. gas is suitable for small molecules; slab is suitable for surface slab models; "
            "bulk is suitable for ion-position only relaxation for bulk with lattice fixed; lattice is suitable for full bulk-ion as well lattice relaxation. "
        ),
    )
    k_product: int = Field(
        30,
        ge=1,
        description="Target k-mesh density via k_i~round(k_product/L_i), min 1, forced odd (Gamma-centered); gas always 1x1x1.",
    )
    use_d3: bool = Field(False, description="Enable DFT-D3 Correction (IVDW=11). Enable it for adsorption calculations.")
    use_dft_plus_u: bool = Field(False, description="Enable DFT+U relevant settings according to materials project standard. Enable it for Transition Metal Oxide systems.")
    user_incar_settings: Optional[Dict[str, Any]] = Field(
        None,
        description=(
            "User INCAR overrides (pymatgen Incar semantics) on top of MPRelaxSet (calc_type presets will always win if conflict with params specified here). "
            "Specify MAGMOM, LDAUU, etc. if user specially needed, format as {\"element\": value}, not a per-atom list. "
            "You can also specify other params, like EDIFF and EDIFFG to control the convergence of the calculation and override the default values."
        ),
    )


def _load_structure(path: Path) -> Structure:
    if path.suffix.lower() == ".xyz":
        atoms = ase_read(path.as_posix())
        return AseAtomsAdaptor.get_structure(atoms)
    return Structure.from_file(path)


def _discover_structures(input_path: Path) -> List[Path]:
    if input_path.is_file():
        return [input_path]
    files = []
    for ext in SUPPORTED_EXTS:
        files.extend(sorted(input_path.rglob(f"*{ext}")))
    return files


def relax_prepare(payload: Dict[str, object]) -> Dict[str, object]:
    params = RelaxPrepareInput(**payload)
    input_path = resolve_workspace_path(params.input_path)
    output_root = resolve_workspace_path(params.output_root)
    calc_type = params.calc_type
    k_product = int(params.k_product)
    user_incar_settings = params.user_incar_settings or {}
    use_d3 = bool(params.use_d3)
    use_dft_plus_u = bool(params.use_dft_plus_u)

    output_root.mkdir(parents=True, exist_ok=True)
    writer = StructWriter()

    structures = _discover_structures(input_path)
    # Auto-detect batch vs single if not explicitly set:
    # - single file => single mode
    # - directory or multiple files => batch mode
    batch_mode = input_path.is_dir() or len(structures) > 1

    emitted: List[Dict[str, object]] = []
    errors: List[Dict[str, str]] = []
    for struct_path in structures:
        try:
            structure = _load_structure(struct_path)
            if input_path.is_dir():
                rel = struct_path.relative_to(input_path)
                rel_parent = rel.parent if rel.parent.as_posix() != "." else Path()
                out_dir = output_root / rel_parent / rel.stem
            else:
                out_dir = output_root / struct_path.stem
            writer.write_vasp_inputs(
                structure=structure,
                output_dir=out_dir,
                calc_type=calc_type,
                k_product=k_product,
                use_d3=use_d3,
                use_dft_plus_u=use_dft_plus_u,
                user_incar_overrides=user_incar_settings,
            )
            emitted.append(
                {
                    "source": str(struct_path),
                    "output_dir": str(out_dir),
                }
            )
        except Exception as exc:
            errors.append({"source": str(struct_path), "error": str(exc)})
            if not batch_mode:
                return create_tool_output(
                    tool_name="relax_prepare",
                    success=False,
                    error=str(exc),
                    data={
                        "calc_type": calc_type,
                        "k_product": k_product,
                        "structures_processed": 0,
                        "errors": errors,
                    },
                )
        if not batch_mode:
            break
    
    # Return standardized output
    return create_tool_output(
        tool_name="relax_prepare",
        success=True,
        data={
            "calc_type": calc_type,
            "k_product": k_product,
            "structures_processed": len(emitted),
            "prepared_directories_rel": [workspace_relpath(Path(e["output_dir"])) for e in emitted],
            "errors_count": len(errors),
            "errors": errors,
        }
    )


__all__ = ["RelaxPrepareInput", "relax_prepare"]
