"""
Prepare MPRelax-style VASP input sets via StructWriter.
"""

from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, List, Optional
from ase.io import read as ase_read
from pydantic import BaseModel, Field
from pymatgen.core import Structure
from pymatgen.io.ase import AseAtomsAdaptor

from .vasp_inputs import StructWriter
from catmaster.tools.base import create_tool_output, resolve_workspace_path, workspace_relpath


SUPPORTED_EXTS = {".vasp", ".cif", ".json", ".xyz"}


class RelaxPrepareInput(BaseModel):
    """
    Prepare MPRelaxSet-based VASP relax inputs with calc_type presets and k_product k-mesh.

    Baseline DFT settings follow Materials Project MPRelaxSet (key defaults:
    - PAW-PBE54 POTCARS, ENCUT=520 eV
    - PREC=Accurate, ISPIN=2, IBRION=2, LREAL=AUTO, LASPH=True, LORBIT=11, LWAVE=False, LCHARG=False).
    - Additional overrides applied for relaxation robustness based on calc_type: EDIFF=1e-6; NSW=500; EDIFFG=-0.02; ISMEAR=0, SIGMA=0.1 for solids; ISMEAR=0, SIGMA=0.01 for gas;
    - KPOINTS is generated by k*a=k_product, where a is the lattice constant in Angstrom. Set to 30 by default and sufficient for most systems.
    - DFT-D3 is enabled by default and DFT+U is disabled by default. Enable it for transition metal oxide systems.
    """

    input_path: str = Field(
        ...,
        description="Path to a structure file with lattice information (POSCAR/CIF) or a directory containing multiple structures. XYZ files are supported.",
    )
    output_root: str = Field(
        ...,
        description="Root directory for generated VASP inputs (one subfolder per input structure). Will generate root/file_names for vasp inputs",
    )
    calc_type: str = Field(
        "bulk",
        description=(
            "Calculation type: 'gas'|'bulk'|'slab'|'lattice'. "
            "This provides preset INCAR overrides: "
            "'lattice' will apply ISIF=3; 'bulk' will apply ISIF=2 (bulk position relaxation only); 'slab' will apply ISIF=2 and force KPOINTS in z direction to 1; "
            "gas will apply ISIF=2, ISYM=0, LREAL=False, ISMEAR=0, SIGMA=0.01, and force KPOINTS to 1x1x1"
        ),
    )
    k_product: int = Field(
        30,
        ge=1,
        description="Target k-mesh density via k_i~round(k_product/L_i), min 1, forced odd (Gamma-centered); gas always 1x1x1.",
    )
    use_d3: bool = Field(True, description="Add IVDW=11 (DFT-D3) to the INCAR if true")
    use_dft_plus_u: bool = Field(False, description="Add LDAU=True to the INCAR if true. Enable it for Transition Metal Oxide systems.")
    user_incar_settings: Optional[Dict[str, Any]] = Field(
        None,
        description=(
            "INCAR overrides (pymatgen Incar semantics) on top of MPRelaxSet (calc_type presets will always win if conflict with params specified here). "
            "Specify MAGMOM, LDAUU, etc. if needed, format as {\"element\": value}, not a per-atom list. "
            "You can also specify EDIFF and EDIFFG to control the convergence of the calculation and override the default values."
        ),
    )


def _load_structure(path: Path) -> Structure:
    if path.suffix.lower() == ".xyz":
        atoms = ase_read(path.as_posix())
        return AseAtomsAdaptor.get_structure(atoms)
    return Structure.from_file(path)


def _discover_structures(input_path: Path) -> List[Path]:
    if input_path.is_file():
        return [input_path]
    files = []
    for ext in SUPPORTED_EXTS:
        files.extend(sorted(input_path.glob(f"*{ext}")))
    return files


def relax_prepare(payload: Dict[str, object]) -> Dict[str, object]:
    params = RelaxPrepareInput(**payload)
    input_path = resolve_workspace_path(params.input_path)
    output_root = resolve_workspace_path(params.output_root)
    calc_type = params.calc_type
    k_product = int(params.k_product)
    user_incar_settings = params.user_incar_settings or {}
    use_d3 = bool(params.use_d3)
    use_dft_plus_u = bool(params.use_dft_plus_u)

    output_root.mkdir(parents=True, exist_ok=True)
    writer = StructWriter()

    structures = _discover_structures(input_path)
    # Auto-detect batch vs single if not explicitly set:
    # - single file => single mode
    # - directory or multiple files => batch mode
    batch_mode = input_path.is_dir() or len(structures) > 1

    emitted: List[Dict[str, object]] = []
    errors: List[Dict[str, str]] = []
    for struct_path in structures:
        try:
            structure = _load_structure(struct_path)
            out_dir = output_root / struct_path.stem if batch_mode else output_root
            writer.write_vasp_inputs(
                structure=structure,
                output_dir=out_dir,
                calc_type=calc_type,
                k_product=k_product,
                use_d3=use_d3,
                use_dft_plus_u=use_dft_plus_u,
                user_incar_overrides=user_incar_settings,
            )
            emitted.append(
                {
                    "source": str(struct_path),
                    "output_dir": str(out_dir),
                }
            )
        except Exception as exc:
            errors.append({"source": str(struct_path), "error": str(exc)})
            if not batch_mode:
                return create_tool_output(
                    tool_name="relax_prepare",
                    success=False,
                    error=str(exc),
                    data={
                        "calc_type": calc_type,
                        "k_product": k_product,
                        "structures_processed": 0,
                        "errors": errors,
                    },
                )
        if not batch_mode:
            break
    
    # Return standardized output
    return create_tool_output(
        tool_name="relax_prepare",
        success=True,
        data={
            "calc_type": calc_type,
            "k_product": k_product,
            "structures_processed": len(emitted),
            "prepared_directories_rel": [workspace_relpath(Path(e["output_dir"])) for e in emitted],
            "errors_count": len(errors),
            "errors": errors,
        }
    )


__all__ = ["RelaxPrepareInput", "relax_prepare"]
